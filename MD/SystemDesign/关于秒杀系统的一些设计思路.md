### 💫上级限流
针对于浏览器端，可以使用JS进行请求过滤，比如5秒钟之类只能点一次抢购按钮，5秒钟只能允许请求一次后端服务。
这样其实就可以过滤掉大部分普通用户。
但是防不住直接抓包循环调用。这种情况可以最简单的处理：在Web层通过限制一个UID在5秒之类的请求服务层的次数(可利用Redis实现)。

具体实现：进入方法时，判断是否包含某个UID，不存在就是第一次请求，那么可以设置一个过期时间和次数；存在就需要判断次数是否为0，不为0减1，为0表示5秒内的请求数已用完。

### 🌺限流降级
限流是解决高并发大流量的一种方案，至少是可以保证应用的可用性。
通常有以下两种限流方案：  
•	漏桶算法  
•	令牌桶算法  
漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了。这种算法很简单，但也非常粗暴，无法应对突发的大流量。 这时可以考虑令牌桶算法。

令牌桶算法是按照恒定的速率向桶中放入令牌，每当一个请求到达时则消耗一个令牌。当桶中的令牌为0时，请求则会被阻塞。
RateLimiter是Guava提供的基于令牌桶算法的实现类，可以非常简单的完成限流特技，并且根据系统的实际情况来调整生成令牌的速率。

例如1秒钟产生10个令牌，实际业务在每次响应请求之前都从桶中获取令牌，只有取到令牌的请求才会被成功响应，获取的方式有两种：阻塞等待令牌 or 取不到令牌立即返回失败。

降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略地降级，以此释放服务器资源以保证核心任务的正常运行。  
比如限流后的降级策略方案可以是：排队页面（将用户导流到排队页面等一会儿重试）以延迟服务、无货（直接告知用户没货了）以拒绝服务、部分用户显示错误页（如活动太火爆了）以随机服务。
总之需要根据不同的业务需求采用不同的降级策略。

### 🎠缓存
对于读请求则尽量使用缓存，可以提前将数据准备好，不管是Redis还是其他缓存中间件效率都是非常高的。即面对高并发时，提前缓存热点数据，采用LRU淘汰算法保证缓存命中率。
对于写请求，也可以通过缓存提升系统的吞吐量或者实现系统的保护措施。
比如读取商品详细数据时使用缓存，当用户点击抢购减少缓存中的库存数量，当库存数为0时或活动期结束时，才同步到数据库。也就是说尽量通过缓存来读取和更新数据，避免对数据库的直接操作。

**简而言之，当处理秒杀业务时，可以采取：JS请求过滤、Redis限制请求次数将请求在上层过滤，用MQ削峰，然后才允许到达业务逻辑，再进行限流降级。**

